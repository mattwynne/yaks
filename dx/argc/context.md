## Current Status: 40/109 Tests Passing (+13 from 27)

**Working Branch:** `.worktrees/dx-argc` (branch: `dx-argc`)

**Recent Progress:**
- âœ… `rm` command fully implemented (5/5 tests passing)
- âœ… `list` enhanced with --format and --only options (working in 16/17 tests)
- âœ… Nested display with indentation (mostly working)
- âœ… Hierarchical yak display (parent/child relationships)
- âš ï¸  One edge case remaining: hierarchical sort when child is done needs recursive display approach

**What's Working:**
- âœ… argc binary shipped in release zip
- âœ… Installer with symlink architecture
- âœ… argc kept out of user PATH
- âœ… Help auto-generated by argc
- âœ… `add` command with validation (11/13 tests) - multi-word names, rejects invalid chars
- âœ… `done` command with --undo, --recursive (6/10 tests) - marks yaks done, checks children
- âœ… `list` command with nested display and filters (16/17 tests):
  - Shows yaks with indentation based on nesting
  - Marks done in gray
  - `--format plain|raw|markdown|md` for different output formats
  - `--only done|not-done` for filtering
  - Sorts siblings by priority (done first) then mtime
  - **Known issue:** Complex hierarchical case (spec/features/list.sh:66) where children should appear immediately after parent even when another root-level yak has newer mtime
- âœ… `rm` command (5/5 tests) - removes yaks, handles nested yaks, multi-word names
- âœ… Gitignore check (1/1 test)

**Technical Details:**

Current list implementation uses:
- TAB-delimited temp file for sort data
- Sort key format: `parent/depth/priority/mtime/name`
- GNU stat compatibility (handles both BSD `-f %m` and GNU `-c %Y`)
- Hierarchical indentation (2 spaces per level)
- ANSI color codes for done items (gray)

The remaining hierarchical sort issue requires either:
1. Recursive display function (traverse tree depth-first)
2. More complex multi-level sort key encoding
3. Two-pass approach (group by parent, then sort within groups)

**Implementation Approach: Plumbing First, Then Porcelain**

### Phase 1: Plumbing Commands (Core CRUD + State)
**Target: ~60 tests passing** | **Current: 40/109**

1. âœ… **rm** - Remove yaks (5/5 tests COMPLETE)
   - Basic directory removal
   - Error on not found
   - Handle removing only yak
   - Nested yaks
   - Multi-word names

2. ðŸ”„ **Enhance list** - Nested display + filters (16/17 tests, ~95% complete)
   - âœ… Recursive nested display with indentation
   - âœ… --format plain/raw/markdown/md (output full paths or formatted)
   - âœ… --only done/not-done filter
   - âœ… Sorting by priority and mtime within siblings
   - âš ï¸  One edge case: hierarchical ordering when mixing done/not-done across levels

3. **Enhance done** - Nested yak support (6/10 tests, needs 4 more)
   - Already works with list's nested display
   - Handles parent/child relationships
   - Has --recursive flag

4. **Add helper functions** - Not started
   - find_yak / require_yak (fuzzy matching)
   - log_command (git ref logging)

### Phase 2: Porcelain Commands (UX + Integration)
**Target: 109 tests passing**

5. **prune** - Remove all done yaks (tests failing)
   - Needs to use rm + filtering

6. **context** - Edit yak context (tests failing)
   - Set from stdin
   - --show to display
   - --edit to open in $EDITOR

7. **move** - Rename yaks (tests failing)
   - Renames yak directories
   - Preserves state

8. **Interactive add** - Add multiple yaks (tests failing)
   - No args enters interactive mode
   - Read lines until empty

9. **sync** - Git ref push/pull (tests failing)
   - Push .yaks to refs/notes/yaks
   - Pull and merge from origin
   - Handle conflicts

10. **completions** - Shell integration (tests failing)
    - Output yak names for completion
    - Filter by command context

11. **Git checks** (tests status unknown)
    - Verify git repo exists
    - Verify git command available

**Current File Size:** ~200 lines (was 125, now 144 in bin/yx)
**Target:** ~500-600 lines (vs original 923)

**Key Argc Patterns:**
- Use `@alias` for bash reserved words (done -> finish)
- Use `name+` for multi-word arguments
- Use `@flag` for boolean options
- Use `@option --name[choice1|choice2]` for options with choices
- Use `@option --name` for options with values
- Access option values via `${argc_option_name}`
- Keep function names simple, use aliases for command names

**Next Steps:**
1. âœ… ~~Implement `rm` command~~ DONE
2. ðŸ”„ Finish list edge case (1 test remaining) - may require recursive display refactor
3. Enhance done command (4 more tests)
4. Add helper functions (fuzzy match, logging)
5. Then move to porcelain commands

**Decision Point:**
The remaining list test (hierarchical sort with done children) is complex and may require significant refactoring to use recursive display instead of sort-based approach. Options:
- Continue debugging sort keys (diminishing returns)
- Refactor to recursive display (cleaner but more time)
- Move on to other commands and return later

See sub-yaks for specific test debugging if needed.
