#!/usr/bin/env bash

YAKS_PATH="${YAKS_PATH:-.yaks}"

# Convert YAKS_PATH to absolute path if relative
case "$YAKS_PATH" in
  /*) ;; # Already absolute
  *) YAKS_PATH="$PWD/$YAKS_PATH" ;;
esac

migrate_done_to_state() {
  if [ ! -d "$YAKS_PATH" ]; then
    return 0
  fi

  # Find all done files and convert them to state files
  while IFS= read -r done_file; do
    local yak_dir=$(dirname "$done_file")
    echo "done" > "$yak_dir/state"
    rm -f "$done_file"
  done < <(find "$YAKS_PATH" -type f -name "done")
}

log_command() {
  # Only commit if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    return 0
  fi

  # Skip if YAKS_PATH doesn't exist
  if [ ! -d "$YAKS_PATH" ]; then
    return 0
  fi

  local commit_message="$*"

  # Use a temporary index to avoid touching the main index
  local temp_index=$(mktemp)
  trap "rm -f '$temp_index'" RETURN

  # Create tree from YAKS_PATH by treating it as the work tree root
  GIT_INDEX_FILE="$temp_index" GIT_WORK_TREE="$YAKS_PATH" git read-tree --empty
  GIT_INDEX_FILE="$temp_index" GIT_WORK_TREE="$YAKS_PATH" git add .
  local tree=$(GIT_INDEX_FILE="$temp_index" git write-tree)

  # Get parent commit if refs/notes/yaks exists
  local parent_args=""
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    parent_args="-p $(git rev-parse refs/notes/yaks)"
  fi

  # Create commit on refs/notes/yaks with proper parent
  local new_commit=$(git commit-tree $tree $parent_args -m "$commit_message")
  git update-ref refs/notes/yaks "$new_commit"

  # Cleanup
  unset GIT_INDEX_FILE
}

validate_yak_name() {
  local name="$1"
  # Reject characters that are invalid on POSIX or Windows: \ : * ? | < > "
  # Forward slash is allowed for nesting
  if [[ "$name" =~ [\\:\*\?\|\<\>\"] ]]; then
    echo "Invalid yak name: contains forbidden characters (\\ : * ? | < > \")" >&2
    return 1
  fi
  return 0
}

find_all_yaks() {
  if [ ! -d "$YAKS_PATH" ]; then
    return 0
  fi
  find "$YAKS_PATH" -mindepth 1 -type d
}

is_yak_done() {
  local yak_path="$1"
  if [ -f "$yak_path/state" ]; then
    local state=$(cat "$yak_path/state")
    [ "$state" = "done" ]
  else
    return 1
  fi
}

find_yak() {
  local search_term="$1"

  # First try exact match
  if [ -d "$YAKS_PATH/$search_term" ]; then
    echo "$search_term"
    return 0
  fi

  # Try fuzzy match - find all yaks containing the search term
  local matches=()
  while IFS= read -r yak_path; do
    local yak_name="${yak_path#$YAKS_PATH/}"
    if [[ "$yak_name" == *"$search_term"* ]]; then
      matches+=("$yak_name")
    fi
  done < <(find_all_yaks)

  # Return based on number of matches
  if [ ${#matches[@]} -eq 0 ]; then
    return 1
  elif [ ${#matches[@]} -eq 1 ]; then
    echo "${matches[0]}"
    return 0
  else
    return 2
  fi
}

require_yak() {
  local yak_name="$1"

  # Use a temp variable to get both output and status
  local temp_file=$(mktemp)
  find_yak "$yak_name" > "$temp_file"
  local status=$?
  local resolved_name=$(cat "$temp_file")
  rm -f "$temp_file"

  if [ $status -eq 0 ]; then
    echo "$resolved_name"
    return 0
  elif [ $status -eq 2 ]; then
    echo "Error: yak name '$yak_name' is ambiguous" >&2
    return 1
  else
    echo "Error: yak '$yak_name' not found" >&2
    return 1
  fi
}

list_yaks() {
  # Parse format option
  local format="markdown"
  if [ "$1" = "--format" ]; then
    format="$2"
    shift 2
  fi

  if [ ! -d "$YAKS_PATH" ] || [ -z "$(ls -A "$YAKS_PATH" 2>/dev/null)" ]; then
    # In plain/raw format, output nothing (for shell completions)
    # In markdown format, show friendly message
    if [ "$format" = "plain" ] || [ "$format" = "raw" ]; then
      return
    else
      echo "You have no yaks. Are you done?"
      return
    fi
  fi

  # Helper function to display a yak in markdown format
  display_yak_markdown() {
    local yak_name="$1"
    local depth=$(echo "$yak_name" | tr -cd '/' | wc -c | xargs)
    local indent=""
    if [ "$depth" -gt 0 ]; then
      indent=$(printf '  %.0s' $(seq 1 $depth))
    fi
    local display_name=$(basename "$yak_name")
    local yak_dir="$YAKS_PATH/$yak_name"

    local state="todo"
    if [ -f "$yak_dir/state" ]; then
      state=$(cat "$yak_dir/state")
    fi

    if [ "$state" = "done" ]; then
      echo -e "\e[90m${indent}- [x] $display_name\e[0m"
    else
      echo "${indent}- [ ] $display_name"
    fi
  }

  # Helper function to display a yak in plain format
  display_yak_plain() {
    local yak_name="$1"
    echo "$yak_name"
  }

  # Select display function based on format
  case "$format" in
    plain|raw)
      display_yak() { display_yak_plain "$@"; }
      ;;
    markdown|md|*)
      display_yak() { display_yak_markdown "$@"; }
      ;;
  esac

  # Recursive function to list yaks in a directory
  list_dir() {
    local parent_dir="$1"

    # Find immediate children (not recursive)
    local children=$(cd "$YAKS_PATH" && find "$parent_dir" -mindepth 1 -maxdepth 1 -type d | sed 's|^\./||')

    # Sort children by: done status (done first), then mtime (oldest first)
    local sorted_children=$(echo "$children" | while read -r child; do
      [ -z "$child" ] && continue
      local full_path="$YAKS_PATH/$child"

      # Get mtime - portable across macOS and Linux
      local mtime
      if stat -f "%m" "$full_path" >/dev/null 2>&1; then
        # macOS/BSD
        mtime=$(stat -f "%m" "$full_path" 2>/dev/null)
      else
        # Linux/GNU
        mtime=$(stat -c "%Y" "$full_path" 2>/dev/null)
      fi

      # Get done status (0 = done, 1 = undone)
      local done_flag=1
      if [ -f "$full_path/state" ]; then
        local state=$(cat "$full_path/state")
        if [ "$state" = "done" ]; then
          done_flag=0
        fi
      fi

      printf "%d\t%015d\t%s\t%s\n" "$done_flag" "$mtime" "$child" "$child"
    done | sort -t$'\t' -k1,1n -k2,2n -k3,3 | cut -f4-)

    # Display each child and recurse
    while IFS= read -r child; do
      [ -z "$child" ] && continue
      display_yak "$child"
      list_dir "$child"
    done <<< "$sorted_children"
  }

  # Start listing from root
  list_dir "."
}

show_help() {
  cat <<EOF
Usage: yx <command> [arguments]

Commands:
  add <name>              Add a new yak
  list, ls [--format FMT] List all yaks
                          --format: Output format
                                    markdown (or md): Checkbox format (default)
                                    plain (or raw): Simple list of names
  context [--show] <name> Edit context (uses \$EDITOR) or set from stdin
                          --show: Display yak with context
                          --edit: Edit context (default)
  done <name>             Mark a yak as done
  done --undo <name>      Unmark a yak as done
  rm <name>               Remove a yak by name
  move <old> <new>        Rename a yak
  mv <old> <new>          Alias for move
  prune                   Remove all done yaks
  sync                    Push and pull yaks to/from origin via git ref
  completions [cmd]       Output yak names for shell completion
  --help                  Show this help message
EOF
}

add_yak() {
  if [ -z "$1" ]; then
    # Interactive mode
    echo "Enter yaks (empty line to finish):"
    mkdir -p "$YAKS_PATH"
    while IFS= read -r line; do
      if [ -z "$line" ]; then
        break
      fi
      validate_yak_name "$line" || exit 1
      mkdir -p "$YAKS_PATH/$line"
      echo "todo" > "$YAKS_PATH/$line/state"
      touch "$YAKS_PATH/$line/context.md"
      log_command "add $line"
    done
  else
    # Single yak mode
    local yak_name="$*"
    validate_yak_name "$yak_name" || exit 1
    mkdir -p "$YAKS_PATH/$yak_name"
    echo "todo" > "$YAKS_PATH/$yak_name/state"
    touch "$YAKS_PATH/$yak_name/context.md"
    log_command "add $yak_name"
  fi
}

done_yak() {
  if [ "$1" = "--undo" ]; then
    local yak_name="${*:2}"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAKS_PATH/$resolved_name"
    echo "todo" > "$yak_path/state"
    log_command "done --undo $resolved_name"
  else
    local yak_name="$*"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAKS_PATH/$resolved_name"
    echo "done" > "$yak_path/state"
    log_command "done $resolved_name"
  fi
}

remove_yak() {
  local yak_name="$*"
  local resolved_name
  resolved_name=$(require_yak "$yak_name") || exit 1
  local yak_path="$YAKS_PATH/$resolved_name"
  rm -rf "$yak_path"
  log_command "rm $resolved_name"
}

prune_yaks() {
  while IFS= read -r yak_path; do
    if is_yak_done "$yak_path"; then
      local yak_name="${yak_path#$YAKS_PATH/}"
      remove_yak "$yak_name"
    fi
  done < <(find_all_yaks)
}

move_yak() {
  local old_name="$1"
  shift
  local new_name="$*"
  local resolved_old
  resolved_old=$(require_yak "$old_name") || exit 1
  local old_path="$YAKS_PATH/$resolved_old"
  local new_path="$YAKS_PATH/$new_name"
  validate_yak_name "$new_name" || exit 1

  # Create parent yaks if they don't exist
  local parent_dir=$(dirname "$new_name")
  if [ "$parent_dir" != "." ]; then
    # Split the parent path and create each level as a yak
    local current_path=""
    IFS='/' read -ra PARTS <<< "$parent_dir"
    for part in "${PARTS[@]}"; do
      if [ -z "$current_path" ]; then
        current_path="$part"
      else
        current_path="$current_path/$part"
      fi
      local yak_path="$YAKS_PATH/$current_path"
      if [ ! -d "$yak_path" ]; then
        mkdir -p "$yak_path"
        echo "todo" > "$yak_path/state"
        touch "$yak_path/context.md"
      fi
    done
  fi

  mv "$old_path" "$new_path"
  log_command "move $resolved_old $new_name"
}

context_yak() {
  if [ "$1" = "--show" ]; then
    # Show mode
    local yak_name="${*:2}"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAKS_PATH/$resolved_name"
    echo "$resolved_name"
    if [ -f "$yak_path/context.md" ]; then
      echo
      cat "$yak_path/context.md"
    fi
  else
    # Edit mode (default or --edit)
    if [ "$1" = "--edit" ]; then
      local yak_name="${*:2}"
    else
      local yak_name="$*"
    fi
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAKS_PATH/$resolved_name"
    if [ -t 0 ]; then
      # stdin is a terminal, open editor
      ${EDITOR:-vi} "$yak_path/context.md"
    else
      # stdin is piped, read from stdin
      cat > "$yak_path/context.md"
    fi
    log_command "context $resolved_name"
  fi
}

install_completions() {
  local dry_run=false
  if [ "$1" = "--dry-run" ]; then
    dry_run=true
  fi

  # Detect shell from $SHELL environment variable
  local shell=""
  local rc_file=""
  local completion_file=""

  if [[ "$SHELL" == *"zsh"* ]]; then
    shell="zsh"
    rc_file="$HOME/.zshrc"
    completion_file="completions/yx.zsh"
  elif [[ "$SHELL" == *"bash"* ]]; then
    shell="bash"
    rc_file="$HOME/.bashrc"
    completion_file="completions/yx.bash"
  else
    echo "Error: Could not detect shell (bash or zsh)" >&2
    return 1
  fi

  # Get absolute path to completions directory
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
  local completion_path="$script_dir/$completion_file"

  if [ "$dry_run" = true ]; then
    echo "Would add to $rc_file:"
    echo "source $completion_path"
    return 0
  fi

  # Check if already installed
  if [ -f "$rc_file" ] && grep -q "source.*$completion_file" "$rc_file" 2>/dev/null; then
    echo "Completions already installed in $rc_file"
    return 0
  fi

  # Try to add source line to rc file
  if echo "" >> "$rc_file" 2>/dev/null && \
     echo "# yx completion" >> "$rc_file" 2>/dev/null && \
     echo "source $completion_path" >> "$rc_file" 2>/dev/null; then
    echo "Installed completions to $rc_file"
    echo "Run 'source $rc_file' or restart your shell to enable completions"
  else
    echo "Error: Failed to write to $rc_file" >&2
    echo "" >&2
    echo "Please add the following line manually to $rc_file:" >&2
    echo "" >&2
    echo "  source $completion_path" >&2
    return 1
  fi
}

completions() {
  # Handle install subcommand
  if [ "$1" = "install" ]; then
    shift
    install_completions "$@"
    return
  fi

  # Output yak names for shell completion
  local cmd="$1"
  local flag="$2"

  # Find all yak directories including nested ones
  while IFS= read -r yak_path; do
    local yak_name="${yak_path#$YAKS_PATH/}"
    local state="todo"
    if [ -f "$yak_path/state" ]; then
      state=$(cat "$yak_path/state")
    fi

    case "$cmd" in
      done)
        if [ "$flag" = "--undo" ]; then
          # Only show done yaks
          if [ "$state" = "done" ]; then
            echo "$yak_name"
          fi
        else
          # Only show incomplete yaks
          if [ "$state" != "done" ]; then
            echo "$yak_name"
          fi
        fi
        ;;
      *)
        # Show all yaks
        echo "$yak_name"
        ;;
    esac
  done < <(find_all_yaks)
}

sync_yaks() {
  # Check if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: not in a git repository" >&2
    exit 1
  fi

  # Check if origin remote exists
  if ! git remote get-url origin > /dev/null 2>&1; then
    echo "Error: no origin remote configured" >&2
    exit 1
  fi

  # Fetch remote refs/notes/yaks FIRST
  git fetch origin refs/notes/yaks:refs/remotes/origin/yaks 2>/dev/null || true

  # Check if we have a remote
  local remote_ref=""
  if git rev-parse refs/remotes/origin/yaks >/dev/null 2>&1; then
    remote_ref=$(git rev-parse refs/remotes/origin/yaks)
  fi

  # Check local state
  local local_ref=""
  local has_local_changes=false
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    local_ref=$(git rev-parse refs/notes/yaks)

    # Check if .yaks differs from what's in refs/notes/yaks
    if [ -d "$YAKS_PATH" ] && [ -n "$(ls -A "$YAKS_PATH" 2>/dev/null)" ]; then
      local check_dir=$(mktemp -d)
      trap "rm -rf '$check_dir'" RETURN
      cp -r "$YAKS_PATH"/. "$check_dir"/

      local ref_dir=$(mktemp -d)
      git archive "$local_ref" | tar -x -C "$ref_dir" 2>/dev/null || true

      if ! diff -r "$check_dir" "$ref_dir" >/dev/null 2>&1; then
        has_local_changes=true
      fi

      rm -rf "$ref_dir"
    fi
  elif [ -d "$YAKS_PATH" ] && [ -n "$(ls -A "$YAKS_PATH" 2>/dev/null)" ]; then
    # No local ref but have .yaks content
    has_local_changes=true
  fi

  # If we have local changes and a remote, merge remote into .yaks first
  if [ "$has_local_changes" = true ] && [ -n "$remote_ref" ]; then
    local temp_dir=$(mktemp -d)
    # Extract remote content
    git archive "$remote_ref" | tar -x -C "$temp_dir" 2>/dev/null || true
    # Copy local .yaks over it (local files win, but remote files are preserved)
    cp -r "$YAKS_PATH"/. "$temp_dir"/
    # Replace .yaks with merged content
    rm -rf "$YAKS_PATH"
    mkdir -p "$YAKS_PATH"
    cp -r "$temp_dir"/. "$YAKS_PATH"/
    rm -rf "$temp_dir"
  fi

  # Commit local changes if any exist
  if [ "$has_local_changes" = true ]; then
    log_command "sync"
    local_ref=$(git rev-parse refs/notes/yaks)
  fi

  # Merge logic: last-write-wins (local overwrites remote on conflict)
  if [ -z "$local_ref" ] && [ -n "$remote_ref" ]; then
    # No local, just use remote
    git update-ref refs/notes/yaks "$remote_ref"
  elif [ -n "$local_ref" ] && [ -z "$remote_ref" ]; then
    # No remote, just push local (handled below)
    :
  elif [ -n "$local_ref" ] && [ -n "$remote_ref" ] && [ "$local_ref" != "$remote_ref" ]; then
    # Both exist and differ - use git merge-tree to merge them
    # Use --allow-unrelated-histories to handle cases where users independently create yaks
    local merged_tree=$(git merge-tree --write-tree --allow-unrelated-histories "$local_ref" "$remote_ref" 2>&1)
    local merge_status=$?

    # Check if merge succeeded
    if [ $merge_status -eq 0 ] && [ -n "$merged_tree" ]; then
      # Create merge commit
      local merge_commit=$(git commit-tree "$merged_tree" \
        -p "$local_ref" \
        -p "$remote_ref" \
        -m "Merge yaks")
      git update-ref refs/notes/yaks "$merge_commit"
    else
      # Merge failed - this should never happen with simple directory structures
      echo "ERROR: git merge-tree failed unexpectedly (status=$merge_status)" >&2
      echo "This is a bug - please report with details of your yak modifications" >&2
      exit 1
    fi
  fi

  # Push to origin
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    git push origin refs/notes/yaks:refs/notes/yaks 2>/dev/null || true
  fi

  # Extract final state to .yaks
  rm -rf "$YAKS_PATH"
  mkdir -p "$YAKS_PATH"
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    git archive refs/notes/yaks | tar -x -C "$YAKS_PATH" 2>/dev/null || true
  fi

  # Clean up remote tracking ref
  git update-ref -d refs/remotes/origin/yaks 2>/dev/null || true
}

# Migrate old done files to state files
migrate_done_to_state

case "$1" in
  --help|"")
    show_help
    ;;
  add)
    shift
    add_yak "$@"
    ;;
  list|ls)
    shift
    list_yaks "$@"
    ;;
  done)
    shift
    done_yak "$@"
    ;;
  rm)
    shift
    remove_yak "$@"
    ;;
  prune)
    prune_yaks
    ;;
  move|mv)
    shift
    move_yak "$@"
    ;;
  context)
    shift
    context_yak "$@"
    ;;
  completions)
    shift
    completions "$@"
    ;;
  sync)
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac
