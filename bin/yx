#!/usr/bin/env bash
# @describe A non-linear TODO list for humans and robots
# @version 0.1.0

# @cmd Add a new yak
# @arg name* The yak name (space-separated words)
add() {
  migrate_done_to_state
  check_git_requirements

  if [ ${#argc_name[@]} -eq 0 ]; then
    add_yak_interactive
  else
    add_yak_single "${argc_name[@]}"
  fi
}

# @cmd List all yaks
# @alias ls
# @option --format[markdown|md|plain|raw] Output format (default: markdown)
# @option --only[done|not-done] Filter by completion status
list() {
  migrate_done_to_state
  check_git_requirements

  # Parse format
  local format="${argc_format:-markdown}"

  # Parse only filter
  local only="${argc_only:-}"

  list_yaks_impl "$format" "$only"
}

# Source library functions
# Resolve symlinks to find the real yx location
YX_REAL_PATH="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || realpath "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
YX_DIR="$(cd "$(dirname "$YX_REAL_PATH")/.." && pwd)"
if [ -f "$YX_DIR/lib/yaks.sh" ]; then
  # shellcheck source=../lib/yaks.sh
  source "$YX_DIR/lib/yaks.sh"
else
  echo "Error: Could not find lib/yaks.sh" >&2
  exit 1
fi

# Argc integration bootstrap - function definitions
# This allows gradual migration to argc-based commands

# Find argc relative to yx installation
find_argc() {
  local yx_real_path="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || realpath "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"
  local argc_path="$yx_real_path/../lib/argc"

  # Use bundled argc if available, otherwise system argc
  if [ -x "$argc_path" ]; then
    echo "$argc_path"
  elif command -v argc >/dev/null 2>&1; then
    command -v argc
  else
    return 1
  fi
}

# Note: Argc evaluation will be added incrementally as commands migrate
# For now, this just sets up the infrastructure

migrate_done_to_state

# Check if git is available (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! command -v git >/dev/null 2>&1; then
    echo "Error: git command not found" >&2
    echo "yx requires git to be installed" >&2
    exit 1
  fi
fi

# Check if we're in a git repository (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! is_git_repository; then
    echo "Error: not in a git repository" >&2
    echo "yx must be run from within a git repository" >&2
    exit 1
  fi
fi

# Check if .yaks folder is gitignored (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! git -C "$GIT_WORK_TREE" check-ignore -q .yaks; then
    echo "Error: .yaks folder is not gitignored" >&2
    echo "Please add .yaks to your .gitignore file" >&2
    exit 1
  fi
fi

case "$1" in
  --help|"")
    # For now, use old help until commands are migrated to argc
    # Argc help will be enabled once @cmd annotations are added
    show_help
    ;;
  add)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    add_yak "$@"
    ;;
  list|ls)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    list_yaks "$@"
    ;;
  done)
    shift
    done_yak "$@"
    ;;
  rm)
    shift
    remove_yak "$@"
    ;;
  prune)
    prune_yaks
    ;;
  move|mv)
    shift
    move_yak "$@"
    ;;
  context)
    shift
    context_yak "$@"
    ;;
  completions)
    shift
    completions "$@"
    ;;
  sync)
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac
