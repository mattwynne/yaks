#!/usr/bin/env bash
# @describe A non-linear TODO list for humans and robots
# @version 0.1.0

# @cmd Add a new yak
# @arg name* The yak name (space-separated words)
add() {
  migrate_done_to_state
  check_git_requirements

  if [ ${#argc_name[@]} -eq 0 ]; then
    add_yak_interactive
  else
    add_yak_single "${argc_name[@]}"
  fi
}

# @cmd List all yaks
# @alias ls
# @option --format[markdown|md|plain|raw] Output format (default: markdown)
# @option --only[done|not-done] Filter by completion status
list() {
  migrate_done_to_state
  check_git_requirements

  # Parse format
  local format="${argc_format:-markdown}"

  # Parse only filter
  local only="${argc_only:-}"

  list_yaks_impl "$format" "$only"
}

# @cmd Mark a yak as done
# @alias done
# @flag --undo Unmark a done yak
# @flag --recursive Mark all children as done too
# @arg name* The yak name
finish() {
  migrate_done_to_state
  check_git_requirements

  local yak_name="${argc_name[*]}"

  if [ "${argc_undo:-0}" = "1" ]; then
    done_yak --undo "$yak_name"
  elif [ "${argc_recursive:-0}" = "1" ]; then
    done_yak --recursive "$yak_name"
  else
    done_yak "$yak_name"
  fi
}

# @cmd Remove a yak
# @alias rm
# @arg name* The yak name
remove() {
  migrate_done_to_state
  check_git_requirements
  remove_yak "${argc_name[*]}"
}

# @cmd Remove all done yaks
prune() {
  migrate_done_to_state
  check_git_requirements
  prune_yaks
}

# @cmd Rename a yak
# @alias mv
# @arg old! The old yak name
# @arg new! The new yak name
move() {
  migrate_done_to_state
  check_git_requirements
  move_yak "$argc_old" "$argc_new"
}

# @cmd Edit or show yak context
# @flag --show Display yak with context
# @flag --edit Edit context (default)
# @arg name* The yak name
context() {
  migrate_done_to_state
  check_git_requirements

  local yak_name="${argc_name[*]}"

  if [ "${argc_show:-0}" = "1" ]; then
    show_yak_context "$yak_name"
  else
    edit_yak_context "$yak_name"
  fi
}

# @cmd Push and pull yaks to/from origin via git ref
sync() {
  migrate_done_to_state
  check_git_requirements
  sync_yaks
}

# @cmd Output yak names for shell completion
# @arg cmd The command being completed
# @arg flag Optional flag being completed
completions() {
  migrate_done_to_state
  check_git_requirements
  completions_impl "$argc_cmd" "${argc_flag:-}"
}

# Find a file relative to yx installation directory (resolving symlinks)
yaks_lib() {
  local relative_path="$1"
  local yx_real_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || realpath "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
  local yx_dir="$(cd "$(dirname "$yx_real_path")/.." && pwd)"
  echo "$yx_dir/$relative_path"
}

# Source library functions
if [ -f "$(yaks_lib lib/yaks.sh)" ]; then
  # shellcheck source=../lib/yaks.sh
  source "$(yaks_lib lib/yaks.sh)"
else
  echo "Error: Could not find lib/yaks.sh" >&2
  exit 1
fi

# Argc integration bootstrap - function definitions
# This allows gradual migration to argc-based commands

# Find argc relative to yx installation
find_argc() {
  local argc_path="$(yaks_lib lib/argc)"

  # Use bundled argc if available, otherwise system argc
  if [ -x "$argc_path" ]; then
    echo "$argc_path"
  elif command -v argc >/dev/null 2>&1; then
    command -v argc
  else
    return 1
  fi
}

# Note: Argc evaluation will be added incrementally as commands migrate
# For now, this just sets up the infrastructure

migrate_done_to_state

# Check if git is available (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! command -v git >/dev/null 2>&1; then
    echo "Error: git command not found" >&2
    echo "yx requires git to be installed" >&2
    exit 1
  fi
fi

# Check if we're in a git repository (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! is_git_repository; then
    echo "Error: not in a git repository" >&2
    echo "yx must be run from within a git repository" >&2
    exit 1
  fi
fi

# Check if .yaks folder is gitignored (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! git -C "$GIT_WORK_TREE" check-ignore -q .yaks; then
    echo "Error: .yaks folder is not gitignored" >&2
    echo "Please add .yaks to your .gitignore file" >&2
    exit 1
  fi
fi

case "$1" in
  --help|"")
    # For now, use old help until commands are migrated to argc
    # Argc help will be enabled once @cmd annotations are added
    show_help
    ;;
  add)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    add_yak "$@"
    ;;
  list|ls)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    list_yaks "$@"
    ;;
  done)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    done_yak "$@"
    ;;
  rm)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    remove_yak "$@"
    ;;
  prune)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    prune_yaks
    ;;
  move|mv)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    move_yak "$@"
    ;;
  context)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    context_yak "$@"
    ;;
  completions)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    shift
    completions_impl "$@"
    ;;
  sync)
    # Try argc first
    argc_bin=$(find_argc)
    if [ $? -eq 0 ]; then
      eval "$("$argc_bin" --argc-eval "$0" "$@")"
      exit $?
    fi
    # Fallback
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac
