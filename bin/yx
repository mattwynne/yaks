#!/usr/bin/env bash

YAK_DIR="${YAK_PATH:-.yaks}"

migrate_done_to_state() {
  if [ ! -d "$YAK_DIR" ]; then
    return 0
  fi

  # Find all done files and convert them to state files
  while IFS= read -r done_file; do
    local yak_dir=$(dirname "$done_file")
    echo "done" > "$yak_dir/state"
    rm -f "$done_file"
  done < <(find "$YAK_DIR" -type f -name "done")
}

log_command() {
  # Only commit if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    return 0
  fi

  # Skip if YAK_DIR doesn't exist or is empty
  if [ ! -d "$YAK_DIR" ] || [ -z "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
    return 0
  fi

  local commit_message="$*"

  # Create a temp directory for the commit
  local temp_dir=$(mktemp -d)
  trap "rm -rf '$temp_dir'" RETURN

  # Copy yaks to temp dir
  cp -r "$YAK_DIR"/. "$temp_dir"/

  # Initialize temp repo and create commit
  git -C "$temp_dir" init --quiet
  git -C "$temp_dir" add -A

  # Get git user info from main repo or use defaults
  local user_name=$(git config user.name 2>/dev/null || echo "Yak User")
  local user_email=$(git config user.email 2>/dev/null || echo "yak@local")
  git -C "$temp_dir" config user.name "$user_name"
  git -C "$temp_dir" config user.email "$user_email"

  git -C "$temp_dir" commit --allow-empty -m "$commit_message" --no-verify --quiet

  # Get the tree from the temp commit
  local tree=$(git -C "$temp_dir" rev-parse HEAD^{tree})

  # Fetch objects from temp repo into main repo
  git fetch "$temp_dir" HEAD >/dev/null 2>&1

  # Get parent commit if refs/notes/yaks exists
  local parent_args=""
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    parent_args="-p $(git rev-parse refs/notes/yaks)"
  fi

  # Create commit on refs/notes/yaks with proper parent
  local new_commit=$(git commit-tree $tree $parent_args -m "$commit_message")
  git update-ref refs/notes/yaks "$new_commit"
}

validate_yak_name() {
  local name="$1"
  # Reject characters that are invalid on POSIX or Windows: \ : * ? | < > "
  # Forward slash is allowed for nesting
  if [[ "$name" =~ [\\:\*\?\|\<\>\"] ]]; then
    echo "Invalid yak name: contains forbidden characters (\\ : * ? | < > \")" >&2
    return 1
  fi
  return 0
}

find_yak() {
  local search_term="$1"

  # First try exact match
  if [ -d "$YAK_DIR/$search_term" ]; then
    echo "$search_term"
    return 0
  fi

  # Try fuzzy match - find all yaks containing the search term
  local matches=()
  if [ -d "$YAK_DIR" ]; then
    while IFS= read -r yak_path; do
      local yak_name="${yak_path#$YAK_DIR/}"
      if [[ "$yak_name" == *"$search_term"* ]]; then
        matches+=("$yak_name")
      fi
    done < <(find "$YAK_DIR" -mindepth 1 -type d)
  fi

  # Return based on number of matches
  if [ ${#matches[@]} -eq 0 ]; then
    return 1
  elif [ ${#matches[@]} -eq 1 ]; then
    echo "${matches[0]}"
    return 0
  else
    return 2
  fi
}

require_yak() {
  local yak_name="$1"

  # Use a temp variable to get both output and status
  local temp_file=$(mktemp)
  find_yak "$yak_name" > "$temp_file"
  local status=$?
  local resolved_name=$(cat "$temp_file")
  rm -f "$temp_file"

  if [ $status -eq 0 ]; then
    echo "$resolved_name"
    return 0
  elif [ $status -eq 2 ]; then
    echo "Error: yak name '$yak_name' is ambiguous" >&2
    return 1
  else
    echo "Error: yak '$yak_name' not found" >&2
    return 1
  fi
}

list_yaks() {
  if [ ! -d "$YAK_DIR" ] || [ -z "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
    echo "You have no yaks. Are you done?"
    return
  fi

  # Helper function to display a yak with proper indentation
  display_yak() {
    local yak_name="$1"
    local depth=$(echo "$yak_name" | tr -cd '/' | wc -c | xargs)
    local indent=""
    if [ "$depth" -gt 0 ]; then
      indent=$(printf '  %.0s' $(seq 1 $depth))
    fi
    local display_name=$(basename "$yak_name")
    local yak_dir="$YAK_DIR/$yak_name"

    local state="todo"
    if [ -f "$yak_dir/state" ]; then
      state=$(cat "$yak_dir/state")
    fi

    if [ "$state" = "done" ]; then
      echo -e "\e[90m${indent}- [x] $display_name\e[0m"
    else
      echo "${indent}- [ ] $display_name"
    fi
  }

  # Recursive function to list yaks in a directory
  list_dir() {
    local parent_dir="$1"

    # Find immediate children (not recursive)
    local children=$(cd "$YAK_DIR" && find "$parent_dir" -mindepth 1 -maxdepth 1 -type d | sed 's|^\./||')

    # Sort children by: done status (done first), then mtime (oldest first)
    local sorted_children=$(echo "$children" | while read -r child; do
      [ -z "$child" ] && continue
      local full_path="$YAK_DIR/$child"

      # Get mtime - portable across macOS and Linux
      local mtime
      if stat -f "%m" "$full_path" >/dev/null 2>&1; then
        # macOS/BSD
        mtime=$(stat -f "%m" "$full_path" 2>/dev/null)
      else
        # Linux/GNU
        mtime=$(stat -c "%Y" "$full_path" 2>/dev/null)
      fi

      # Get done status (0 = done, 1 = undone)
      local done_flag=1
      if [ -f "$full_path/state" ]; then
        local state=$(cat "$full_path/state")
        if [ "$state" = "done" ]; then
          done_flag=0
        fi
      fi

      printf "%d\t%015d\t%s\t%s\n" "$done_flag" "$mtime" "$child" "$child"
    done | sort -t$'\t' -k1,1n -k2,2n -k3,3 | cut -f4-)

    # Display each child and recurse
    while IFS= read -r child; do
      [ -z "$child" ] && continue
      display_yak "$child"
      list_dir "$child"
    done <<< "$sorted_children"
  }

  # Start listing from root
  list_dir "."
}

show_help() {
  cat <<EOF
Usage: yx <command> [arguments]

Commands:
  add <name>              Add a new yak
  list, ls                List all yaks
  context [--show] <name> Edit context (uses \$EDITOR) or set from stdin
                          --show: Display yak with context
                          --edit: Edit context (default)
  done <name>             Mark a yak as done
  done --undo <name>      Unmark a yak as done
  rm <name>               Remove a yak by name
  move <old> <new>        Rename a yak
  mv <old> <new>          Alias for move
  prune                   Remove all done yaks
  sync                    Push and pull yaks to/from origin via git ref
  completions [cmd]       Output yak names for shell completion
  --help                  Show this help message
EOF
}

add_yak() {
  if [ -z "$1" ]; then
    # Interactive mode
    echo "Enter yaks (empty line to finish):"
    mkdir -p "$YAK_DIR"
    while IFS= read -r line; do
      if [ -z "$line" ]; then
        break
      fi
      validate_yak_name "$line" || exit 1
      mkdir -p "$YAK_DIR/$line"
      echo "todo" > "$YAK_DIR/$line/state"
      touch "$YAK_DIR/$line/context.md"
      log_command "add $line"
    done
  else
    # Single yak mode
    local yak_name="$*"
    validate_yak_name "$yak_name" || exit 1
    mkdir -p "$YAK_DIR/$yak_name"
    echo "todo" > "$YAK_DIR/$yak_name/state"
    touch "$YAK_DIR/$yak_name/context.md"
    log_command "add $yak_name"
  fi
}

done_yak() {
  if [ "$1" = "--undo" ]; then
    local yak_name="${*:2}"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAK_DIR/$resolved_name"
    echo "todo" > "$yak_path/state"
    log_command "done --undo $resolved_name"
  else
    local yak_name="$*"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAK_DIR/$resolved_name"
    echo "done" > "$yak_path/state"
    log_command "done $resolved_name"
  fi
}

remove_yak() {
  local yak_name="$*"
  local resolved_name
  resolved_name=$(require_yak "$yak_name") || exit 1
  local yak_path="$YAK_DIR/$resolved_name"
  rm -rf "$yak_path"
  log_command "rm $resolved_name"
}

prune_yaks() {
  if [ -d "$YAK_DIR" ]; then
    local pruned=false
    for yak_dir in "$YAK_DIR"/*; do
      if [ -d "$yak_dir" ] && [ -f "$yak_dir/state" ]; then
        local state=$(cat "$yak_dir/state")
        if [ "$state" = "done" ]; then
          rm -rf "$yak_dir"
          pruned=true
        fi
      fi
    done
    if [ "$pruned" = "true" ]; then
      log_command "prune"
    fi
  fi
}

move_yak() {
  local old_name="$1"
  shift
  local new_name="$*"
  local resolved_old
  resolved_old=$(require_yak "$old_name") || exit 1
  local old_path="$YAK_DIR/$resolved_old"
  local new_path="$YAK_DIR/$new_name"
  validate_yak_name "$new_name" || exit 1
  mv "$old_path" "$new_path"
  log_command "move $resolved_old $new_name"
}

context_yak() {
  if [ "$1" = "--show" ]; then
    # Show mode
    local yak_name="${*:2}"
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAK_DIR/$resolved_name"
    echo "$resolved_name"
    if [ -f "$yak_path/context.md" ]; then
      echo
      cat "$yak_path/context.md"
    fi
  else
    # Edit mode (default or --edit)
    if [ "$1" = "--edit" ]; then
      local yak_name="${*:2}"
    else
      local yak_name="$*"
    fi
    local resolved_name
    resolved_name=$(require_yak "$yak_name") || exit 1
    local yak_path="$YAK_DIR/$resolved_name"
    if [ -t 0 ]; then
      # stdin is a terminal, open editor
      ${EDITOR:-vi} "$yak_path/context.md"
    else
      # stdin is piped, read from stdin
      cat > "$yak_path/context.md"
    fi
    log_command "context $resolved_name"
  fi
}

completions() {
  # Output yak names for shell completion
  if [ ! -d "$YAK_DIR" ]; then
    return 0
  fi
  local cmd="$1"
  local flag="$2"

  # Find all yak directories including nested ones
  while IFS= read -r yak_path; do
    local yak_name="${yak_path#$YAK_DIR/}"
    local state="todo"
    if [ -f "$yak_path/state" ]; then
      state=$(cat "$yak_path/state")
    fi

    case "$cmd" in
      done)
        if [ "$flag" = "--undo" ]; then
          # Only show done yaks
          if [ "$state" = "done" ]; then
            echo "$yak_name"
          fi
        else
          # Only show incomplete yaks
          if [ "$state" != "done" ]; then
            echo "$yak_name"
          fi
        fi
        ;;
      *)
        # Show all yaks
        echo "$yak_name"
        ;;
    esac
  done < <(find "$YAK_DIR" -mindepth 1 -type d)
}

sync_yaks() {
  # Check if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: not in a git repository" >&2
    exit 1
  fi

  # Check if origin remote exists
  if ! git remote get-url origin > /dev/null 2>&1; then
    echo "Error: no origin remote configured" >&2
    exit 1
  fi

  # Fetch remote refs/notes/yaks FIRST
  git fetch origin refs/notes/yaks:refs/remotes/origin/yaks 2>/dev/null || true

  # Check if we have a remote
  local remote_ref=""
  if git rev-parse refs/remotes/origin/yaks >/dev/null 2>&1; then
    remote_ref=$(git rev-parse refs/remotes/origin/yaks)
  fi

  # Check local state
  local local_ref=""
  local has_local_changes=false
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    local_ref=$(git rev-parse refs/notes/yaks)

    # Check if .yaks differs from what's in refs/notes/yaks
    if [ -d "$YAK_DIR" ] && [ -n "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
      local check_dir=$(mktemp -d)
      trap "rm -rf '$check_dir'" RETURN
      cp -r "$YAK_DIR"/. "$check_dir"/

      local ref_dir=$(mktemp -d)
      git archive "$local_ref" | tar -x -C "$ref_dir" 2>/dev/null || true

      if ! diff -r "$check_dir" "$ref_dir" >/dev/null 2>&1; then
        has_local_changes=true
      fi

      rm -rf "$ref_dir"
    fi
  elif [ -d "$YAK_DIR" ] && [ -n "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
    # No local ref but have .yaks content
    has_local_changes=true
  fi

  # If we have local changes and a remote, merge remote into .yaks first
  if [ "$has_local_changes" = true ] && [ -n "$remote_ref" ]; then
    local temp_dir=$(mktemp -d)
    # Extract remote content
    git archive "$remote_ref" | tar -x -C "$temp_dir" 2>/dev/null || true
    # Copy local .yaks over it (local files win, but remote files are preserved)
    cp -r "$YAK_DIR"/. "$temp_dir"/
    # Replace .yaks with merged content
    rm -rf "$YAK_DIR"
    mkdir -p "$YAK_DIR"
    cp -r "$temp_dir"/. "$YAK_DIR"/
    rm -rf "$temp_dir"
  fi

  # Commit local changes if any exist
  if [ "$has_local_changes" = true ]; then
    log_command "sync"
    local_ref=$(git rev-parse refs/notes/yaks)
  fi

  # Merge logic: last-write-wins (local overwrites remote on conflict)
  if [ -z "$local_ref" ] && [ -n "$remote_ref" ]; then
    # No local, just use remote
    git update-ref refs/notes/yaks "$remote_ref"
  elif [ -n "$local_ref" ] && [ -z "$remote_ref" ]; then
    # No remote, just push local (handled below)
    :
  elif [ -n "$local_ref" ] && [ -n "$remote_ref" ] && [ "$local_ref" != "$remote_ref" ]; then
    # Both exist and differ - use git merge-tree to merge them
    # Use --allow-unrelated-histories to handle cases where users independently create yaks
    local merged_tree=$(git merge-tree --write-tree --allow-unrelated-histories "$local_ref" "$remote_ref" 2>&1)
    local merge_status=$?

    # Check if merge succeeded
    if [ $merge_status -eq 0 ] && [ -n "$merged_tree" ]; then
      # Create merge commit
      local merge_commit=$(git commit-tree "$merged_tree" \
        -p "$local_ref" \
        -p "$remote_ref" \
        -m "Merge yaks")
      git update-ref refs/notes/yaks "$merge_commit"
    else
      # Merge failed - use timestamp-based last-write-wins fallback
      local local_time=$(git log -1 --format=%ct "$local_ref" 2>/dev/null)
      local remote_time=$(git log -1 --format=%ct "$remote_ref" 2>/dev/null)

      if [ "$local_time" -gt "$remote_time" ]; then
        # Local wins
        : # refs/notes/yaks already points to local_ref
      else
        # Remote wins
        git update-ref refs/notes/yaks "$remote_ref"
      fi
    fi
  fi

  # Push to origin
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    git push origin refs/notes/yaks:refs/notes/yaks 2>/dev/null || true
  fi

  # Extract final state to .yaks
  rm -rf "$YAK_DIR"
  mkdir -p "$YAK_DIR"
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    git archive refs/notes/yaks | tar -x -C "$YAK_DIR" 2>/dev/null || true
  fi

  # Clean up remote tracking ref
  git update-ref -d refs/remotes/origin/yaks 2>/dev/null || true
}

# Migrate old done files to state files
migrate_done_to_state

case "$1" in
  --help|"")
    show_help
    ;;
  add)
    shift
    add_yak "$@"
    ;;
  list|ls)
    list_yaks
    ;;
  done)
    shift
    done_yak "$@"
    ;;
  rm)
    shift
    remove_yak "$@"
    ;;
  prune)
    prune_yaks
    ;;
  move|mv)
    shift
    move_yak "$@"
    ;;
  context)
    shift
    context_yak "$@"
    ;;
  completions)
    shift
    completions "$@"
    ;;
  sync)
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac
