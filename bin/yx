#!/usr/bin/env bash

# Source library functions
YX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
if [ -f "$YX_DIR/lib/yaks.sh" ]; then
  # shellcheck source=../lib/yaks.sh
  source "$YX_DIR/lib/yaks.sh"
else
  echo "Error: Could not find lib/yaks.sh" >&2
  exit 1
fi

migrate_done_to_state

# Check if git is available (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! command -v git >/dev/null 2>&1; then
    echo "Error: git command not found" >&2
    echo "yx requires git to be installed" >&2
    exit 1
  fi
fi

# Check if we're in a git repository (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! is_git_repository; then
    echo "Error: not in a git repository" >&2
    echo "yx must be run from within a git repository" >&2
    exit 1
  fi
fi

# Check if .yaks folder is gitignored (except for help commands)
if [ "$1" != "--help" ] && [ -n "$1" ]; then
  if ! git -C "$GIT_WORK_TREE" check-ignore -q .yaks; then
    echo "Error: .yaks folder is not gitignored" >&2
    echo "Please add .yaks to your .gitignore file" >&2
    exit 1
  fi
fi

case "$1" in
  --help|"")
    show_help
    ;;
  add)
    shift
    add_yak "$@"
    ;;
  list|ls)
    shift
    list_yaks "$@"
    ;;
  done)
    shift
    done_yak "$@"
    ;;
  rm)
    shift
    remove_yak "$@"
    ;;
  prune)
    prune_yaks
    ;;
  move|mv)
    shift
    move_yak "$@"
    ;;
  context)
    shift
    context_yak "$@"
    ;;
  completions)
    shift
    completions "$@"
    ;;
  sync)
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac

# Argc integration bootstrap
# This allows gradual migration to argc-based commands

# Find argc relative to yx installation
find_argc() {
  local yx_real_path="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || realpath "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"
  local argc_path="$yx_real_path/../lib/argc"

  # Use bundled argc if available, otherwise system argc
  if [ -x "$argc_path" ]; then
    echo "$argc_path"
  elif command -v argc >/dev/null 2>&1; then
    command -v argc
  else
    return 1
  fi
}

# Note: Argc evaluation will be added incrementally as commands migrate
# For now, this just sets up the infrastructure
