#!/usr/bin/env bash

YAK_DIR="${YAK_PATH:-.yaks}"

validate_yak_name() {
  local name="$1"
  # Reject characters that are invalid on POSIX or Windows: \ : * ? | < > "
  # Forward slash is allowed for nesting
  if [[ "$name" =~ [\\:\*\?\|\<\>\"] ]]; then
    echo "Invalid yak name: contains forbidden characters (\\ : * ? | < > \")" >&2
    return 1
  fi
  return 0
}

require_yak() {
  local yak_name="$1"
  local yak_path="$YAK_DIR/$yak_name"
  if [ ! -d "$yak_path" ]; then
    echo "Error: yak '$yak_name' not found" >&2
    return 1
  fi
  return 0
}

list_yaks() {
  if [ ! -d "$YAK_DIR" ] || [ -z "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
    echo "You have no yaks. Are you done?"
    return
  fi

  # Find all yak directories and sort them:
  # 1. By directory depth (parents before children)
  # 2. By creation time (oldest first) within each level
  local all_yaks
  all_yaks=$(cd "$YAK_DIR" && find . -mindepth 1 -type d | while read -r path; do
    depth=$(echo "$path" | tr -cd '/' | wc -c)
    # Get mtime - portable across macOS and Linux
    if stat -f "%m" "$path" >/dev/null 2>&1; then
      # macOS/BSD
      mtime=$(stat -f "%m" "$path")
    else
      # Linux/GNU
      mtime=$(stat -c "%Y" "$path")
    fi
    printf "%d %s %s\n" "$depth" "$mtime" "$path"
  done | sort -k1,1n -k2,2n | cut -d' ' -f3- | sed 's|^\./||')

  # Helper function to display a yak with proper indentation
  display_yak() {
    local yak_name="$1"
    local is_done="$2"
    local depth=$(echo "$yak_name" | tr -cd '/' | wc -c | xargs)
    local indent=""
    if [ "$depth" -gt 0 ]; then
      indent=$(printf '  %.0s' $(seq 1 $depth))
    fi
    local display_name=$(basename "$yak_name")

    if [ "$is_done" = "true" ]; then
      echo -e "${indent}\e[90m- [x] $display_name\e[0m"
    else
      echo "${indent}- [ ] $display_name"
    fi
  }

  # Collect all yaks in arrays
  local -a done_yaks
  local -a undone_yaks

  while IFS= read -r yak_name; do
    local yak_dir="$YAK_DIR/$yak_name"
    if [ -f "$yak_dir/done" ]; then
      done_yaks+=("$yak_name")
    else
      undone_yaks+=("$yak_name")
    fi
  done <<< "$all_yaks"

  # Display done yaks first
  for yak_name in "${done_yaks[@]}"; do
    display_yak "$yak_name" "true"
  done

  # Display undone yaks
  for yak_name in "${undone_yaks[@]}"; do
    display_yak "$yak_name" "false"
  done
}

show_help() {
  cat <<EOF
Usage: yx <command> [arguments]

Commands:
  add <name>              Add a new yak
  list, ls                List all yaks
  context [--show] <name> Edit context (uses \$EDITOR) or set from stdin
                          --show: Display yak with context
                          --edit: Edit context (default)
  done <name>             Mark a yak as done
  done --undo <name>      Unmark a yak as done
  rm <name>               Remove a yak by name
  move <old> <new>        Rename a yak
  mv <old> <new>          Alias for move
  prune                   Remove all done yaks
  sync                    Push and pull yaks to/from origin via git ref
  completions [cmd]       Output yak names for shell completion
  --help                  Show this help message
EOF
}

add_yak() {
  if [ -z "$1" ]; then
    # Interactive mode
    echo "Enter yaks (empty line to finish):"
    mkdir -p "$YAK_DIR"
    while IFS= read -r line; do
      if [ -z "$line" ]; then
        break
      fi
      validate_yak_name "$line" || exit 1
      mkdir -p "$YAK_DIR/$line"
    done
  else
    # Single yak mode
    local yak_name="$*"
    validate_yak_name "$yak_name" || exit 1
    mkdir -p "$YAK_DIR/$yak_name"
  fi
}

done_yak() {
  if [ "$1" = "--undo" ]; then
    local yak_name="${*:2}"
    require_yak "$yak_name" || exit 1
    local yak_path="$YAK_DIR/$yak_name"
    rm -f "$yak_path/done"
  else
    local yak_name="$*"
    require_yak "$yak_name" || exit 1
    local yak_path="$YAK_DIR/$yak_name"
    touch "$yak_path/done"
  fi
}

remove_yak() {
  local yak_name="$*"
  require_yak "$yak_name" || exit 1
  local yak_path="$YAK_DIR/$yak_name"
  rm -rf "$yak_path"
}

prune_yaks() {
  if [ -d "$YAK_DIR" ]; then
    for yak_dir in "$YAK_DIR"/*; do
      if [ -d "$yak_dir" ] && [ -f "$yak_dir/done" ]; then
        rm -rf "$yak_dir"
      fi
    done
  fi
}

move_yak() {
  local old_name="$1"
  shift
  local new_name="$*"
  require_yak "$old_name" || exit 1
  local old_path="$YAK_DIR/$old_name"
  local new_path="$YAK_DIR/$new_name"
  validate_yak_name "$new_name" || exit 1
  mv "$old_path" "$new_path"
}

context_yak() {
  if [ "$1" = "--show" ]; then
    # Show mode
    local yak_name="${*:2}"
    require_yak "$yak_name" || exit 1
    local yak_path="$YAK_DIR/$yak_name"
    echo "$yak_name"
    if [ -f "$yak_path/context.md" ]; then
      echo
      cat "$yak_path/context.md"
    fi
  else
    # Edit mode (default or --edit)
    if [ "$1" = "--edit" ]; then
      local yak_name="${*:2}"
    else
      local yak_name="$*"
    fi
    require_yak "$yak_name" || exit 1
    local yak_path="$YAK_DIR/$yak_name"
    if [ -t 0 ]; then
      # stdin is a terminal, open editor
      ${EDITOR:-vi} "$yak_path/context.md"
    else
      # stdin is piped, read from stdin
      cat > "$yak_path/context.md"
    fi
  fi
}

completions() {
  # Output yak names for shell completion
  if [ ! -d "$YAK_DIR" ]; then
    return 0
  fi
  local cmd="$1"
  local flag="$2"

  # Find all yak directories including nested ones
  while IFS= read -r yak_path; do
    local yak_name="${yak_path#$YAK_DIR/}"
    case "$cmd" in
      done)
        if [ "$flag" = "--undo" ]; then
          # Only show done yaks
          if [ -f "$yak_path/done" ]; then
            echo "$yak_name"
          fi
        else
          # Only show incomplete yaks
          if [ ! -f "$yak_path/done" ]; then
            echo "$yak_name"
          fi
        fi
        ;;
      *)
        # Show all yaks
        echo "$yak_name"
        ;;
    esac
  done < <(find "$YAK_DIR" -mindepth 1 -type d)
}

sync_yaks() {
  # Check if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: not in a git repository" >&2
    exit 1
  fi

  # Check if origin remote exists
  if ! git remote get-url origin > /dev/null 2>&1; then
    echo "Error: no origin remote configured" >&2
    exit 1
  fi

  # Create .yaks directory if it doesn't exist
  mkdir -p "$YAK_DIR"

  # First, fetch from origin to get latest remote state
  git fetch origin refs/notes/yaks:refs/notes/yaks 2>/dev/null || true

  # Create a temporary directory to merge local and remote yaks
  local sync_dir=$(mktemp -d)
  trap "rm -rf '$sync_dir'" EXIT

  # Extract remote yaks to sync_dir if they exist
  if git rev-parse refs/notes/yaks > /dev/null 2>&1; then
    git --work-tree="$sync_dir" checkout refs/notes/yaks -- . 2>/dev/null || true
  fi

  # Merge local yaks into sync_dir (overwrites remote yaks with same name)
  if [ -d "$YAK_DIR" ] && [ "$(ls -A "$YAK_DIR" 2>/dev/null)" ]; then
    cp -r "$YAK_DIR"/. "$sync_dir"/
  fi

  # Add .yak marker files to ensure git tracks all directories
  if [ -d "$sync_dir" ] && [ "$(ls -A "$sync_dir" 2>/dev/null)" ]; then
    find "$sync_dir" -mindepth 1 -type d -exec touch {}/.yak \;
  fi

  # Initialize temp repo and commit
  git -C "$sync_dir" init --quiet
  (cd "$sync_dir" && \
    git add -A && \
    git config user.email "yak@sync" && \
    git config user.name "Yak Sync" && \
    git commit --allow-empty -m "Sync yaks" --quiet)

  # Get the parent commit (current refs/notes/yaks)
  local parent_commit=""
  if git rev-parse refs/notes/yaks >/dev/null 2>&1; then
    parent_commit=$(git rev-parse refs/notes/yaks 2>/dev/null)
  fi

  # Fetch the commit from temp repo into main repo
  git fetch "$sync_dir" HEAD >/dev/null 2>&1

  # Create a new commit on refs/notes/yaks with proper parent
  if [ -n "$parent_commit" ] && git rev-parse "$parent_commit" >/dev/null 2>&1; then
    local temp_commit=$(git rev-parse FETCH_HEAD 2>/dev/null)
    local tree=$(git rev-parse "$temp_commit^{tree}" 2>/dev/null)
    local new_commit=$(git commit-tree "$tree" -p "$parent_commit" -m "Sync yaks" 2>/dev/null)
    git update-ref refs/notes/yaks "$new_commit"
  else
    git update-ref refs/notes/yaks FETCH_HEAD
  fi

  # Push refs/notes/yaks to origin
  git push origin refs/notes/yaks:refs/notes/yaks 2>/dev/null || true

  # Extract final yaks back to YAK_DIR
  rm -rf "$YAK_DIR"
  mkdir -p "$YAK_DIR"
  git --work-tree="$YAK_DIR" checkout refs/notes/yaks -- . 2>/dev/null || true

  rm -rf "$sync_dir"
}

case "$1" in
  --help|"")
    show_help
    ;;
  add)
    shift
    add_yak "$@"
    ;;
  list|ls)
    list_yaks
    ;;
  done)
    shift
    done_yak "$@"
    ;;
  rm)
    shift
    remove_yak "$@"
    ;;
  prune)
    prune_yaks
    ;;
  move|mv)
    shift
    move_yak "$@"
    ;;
  context)
    shift
    context_yak "$@"
    ;;
  completions)
    shift
    completions "$@"
    ;;
  sync)
    sync_yaks
    ;;
  *)
    show_help
    ;;
esac
